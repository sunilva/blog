
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Understanding Paxos With Three Simple Rules - Slow Host</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#introduction" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Slow Host" class="md-header__button md-logo" aria-label="Slow Host" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Slow Host
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Understanding Paxos With Three Simple Rules
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../about/" class="md-tabs__link">
        
  
  
    
  
  About

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
                
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" hidden>
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Slow Host" class="md-nav__button md-logo" aria-label="Slow Host" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Slow Host
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../about/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    About
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
                
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      
        Introduction
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#environment" class="md-nav__link">
    <span class="md-ellipsis">
      
        Environment
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#system" class="md-nav__link">
    <span class="md-ellipsis">
      
        System
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#safety-liveness" class="md-nav__link">
    <span class="md-ellipsis">
      
        Safety &amp; Liveness
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#consensus" class="md-nav__link">
    <span class="md-ellipsis">
      
        Consensus
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rule-one-proposers-retry" class="md-nav__link">
    <span class="md-ellipsis">
      
        Rule-One: Proposers Retry
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rule-two-kill-the-past" class="md-nav__link">
    <span class="md-ellipsis">
      
        Rule-Two: Kill The Past
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rule-three-past-is-prologue" class="md-nav__link">
    <span class="md-ellipsis">
      
        Rule-Three: Past Is Prologue
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#paxos-protocol" class="md-nav__link">
    <span class="md-ellipsis">
      
        Paxos Protocol
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#discussion" class="md-nav__link">
    <span class="md-ellipsis">
      
        Discussion
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Discussion">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#moment-of-consensus" class="md-nav__link">
    <span class="md-ellipsis">
      
        Moment of consensus
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#time-order" class="md-nav__link">
    <span class="md-ellipsis">
      
        Time &amp; Order
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#safety-liveness_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        Safety &amp; Liveness
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asynchrony" class="md-nav__link">
    <span class="md-ellipsis">
      
        Asynchrony
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  
  




  <h1>Understanding Paxos With Three Simple Rules</h1>

<h3 id="introduction"><strong>Introduction</strong><a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h3>
<p>Consensus is defined as a group of processes(host machines) agreeing on a single value or request.
Such a group of processes provide redundancy using which fault tolerant systems can be built.</p>
<p>For building practical fault tolerant systems the group of processes need to agree on a series of requests while maintaining the
relative order of the requests. Such a group of processes can be used to implement a Replicated State Machine<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup><sup>,</sup><sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>(RSM).
We will not discuss about RSM in this post, only single value agreement called single decree paxos will be discussed.</p>
<p>Consensus algorithm should meet the following conditions<sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup>:</p>
<div class="admonition note narrow">
<ul>
<li><strong>Agreement:</strong> A single value is chosen.</li>
<li><strong>Validity:</strong> The value agreed upon value is actually proposed. This is to avoid trivial solutions,
all processes can simply decide on a fixed value, say 42, no matter what.</li>
<li><strong>Termination:</strong> Eventually a value gets chosen.</li>
</ul>
</div>
<h3 id="environment"><strong>Environment</strong><a class="headerlink" href="#environment" title="Permanent link">&para;</a></h3>
<p>An algorithm needs to consider the environment in which it is supposed to work. Following are the assumptions w.r.t 
processes &amp; the network that make up the system. Processes communicate with each other by sending messages over the network.</p>
<p><strong><em>Process:</em></strong></p>
<ul>
<li>Processes run at arbitrary speeds, hence a process can take arbitrary time to respond back to a message.</li>
<li>Processes may crash &amp; restart. It is assumed that processes are equipped with stable storage to remember the chosen value across a crash. </li>
</ul>
<p><strong><em>Network:</em></strong></p>
<ul>
<li>Messages can get arbitrarily delayed in the network.</li>
<li>Messages can get duplicated, reordered or lost.</li>
</ul>
<p>Since the processes &amp; network don't provide any guarantee w.r.t time, the system is said to be <strong>asynchronous</strong>.
In an asynchronous system, the algorithm should not make any assumption w.r.t time(<em>bounded message delay or processing time</em>) 
i.e typical mechanisms like <strong>timeout</strong> can't be used.</p>
<p>The net effect of above assumptions w.r.t timinig is that, in an asynchronous system, it is not possible to determine a process failure.
Suppose process <strong>P1</strong> sends a message to another process <strong>P2</strong>. The reply from the process <strong>P2</strong> can't be expected in bounded time either because the 
reply gets delayed in the network or the process might be acting slow. Hence failure detection is not possible as failure to receive response 
can't be attributed to process failure. The network/process delay can be infinite, theoretically.</p>
<div class="admonition note narrow">
<p><center><strong><em>In an aysnchronous system, deterministic failure detection of a process is impossible due to message/process delay</em></strong></p>
</div>
<p>Note that the timing assumptions are fundamental while persistent storage &amp; message loss, duplication &amp; reordering are engineering challenges.
Message loss can be handled through retry(which can lead to duplication), message duplication &amp; reordering can be handled by numbering the messages.</p>
<h3 id="system"><strong>System</strong><a class="headerlink" href="#system" title="Permanent link">&para;</a></h3>
<p>The system (depicted in the picture below) consists of proposers &amp; acceptors. 
Proposers receive requests from external clients &amp; propose the requests to the acceptors.
Proposers don't hold any system state, it's the acceptors which hold the system state i.e the accepted value.
The algorithm doesn't require proposers or acceptors to communicate among themselves inorder to achieve consensus.
It is possible for a single process to act as both an acceptor &amp; a proposer, for simplicity acceptors &amp; proposers will be considered to be distinct.</p>
<div class="admonition note inline left">
<div class="language-text highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>client requests   P: Proposer
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a>      |           A: Acceptor
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>    --------      R: Request
</span><span id="__span-0-4"><a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a>    |      |
</span><span id="__span-0-5"><a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a>    R1     R2
</span><span id="__span-0-6"><a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a>    |      |
</span><span id="__span-0-7"><a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a>    \/     \/                            
</span><span id="__span-0-8"><a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a>+----------------+
</span><span id="__span-0-9"><a id="__codelineno-0-9" name="__codelineno-0-9" href="#__codelineno-0-9"></a>| P1 P2 P3 ..    |
</span><span id="__span-0-10"><a id="__codelineno-0-10" name="__codelineno-0-10" href="#__codelineno-0-10"></a>| A1 A2 A3 ...An |
</span><span id="__span-0-11"><a id="__codelineno-0-11" name="__codelineno-0-11" href="#__codelineno-0-11"></a>+----------------+
</span></code></pre></div>
</div>
<div class="admonition question">
<p class="admonition-title">Why are multiple proposers required?</p>
<p><em>Multiple acceptors are required to provide redundancy but why do we need more than one proposer to be present at the same time?
Since a proposer is only required to propose a value &amp; doesn't hold any system state, it should be possible to replace it in case of failure.</em>   </p>
<p>While a proposer can be replaced <strong>suspecting</strong> failure, it is not possible to tell whether the proposer is dead as determinisitic process failure 
detection is impossible in an asynchronous system. Hence it becomes imperative to assume the presence of more than one proposer at the same time.</p>
</div>
<h3 id="safety-liveness"><strong>Safety &amp; Liveness</strong><a class="headerlink" href="#safety-liveness" title="Permanent link">&para;</a></h3>
<p>Leslie Lamport introduced the concept of safety &amp; liveness properties to define the <strong>correctness</strong><sup id="fnref:4"><a class="footnote-ref" href="#fn:4">4</a></sup>(i.e behave as expected) of an algorithm.
Informally(proved formally<sup id="fnref:5"><a class="footnote-ref" href="#fn:5">5</a></sup>), they are defined as:</p>
<ul>
<li>Safety: Something bad never happens.</li>
<li>Liveness: Something good will eventually happen.</li>
</ul>
<p>They are conditions expressed on the execution of an algorithm. 
Safety is the condition to prevent something bad from ever happening 
while liveness is the condition to express something good will happen eventually.
Safety condition is expected to hold true always, ensuring every step of an algorithm's execution is correct. 
Liveness condition holds true eventually &amp; hence it can be thought of as the condition to express the end result. </p>
<p>For instance, safety &amp; liveness properties for mutex are given below:</p>
<ul>
<li>Safety: No two processes should be executing the critical section at the same time. </li>
<li>Liveness: Every process should eventually get a chance to execute the critical section.</li>
</ul>
<p>With respect to consensus, <strong>Agreement &amp; Validity</strong> are safety properties and <strong>Termination</strong> is liveness property.
Paxos has some issue w.r.t liveness owing to FLP<sup id="fnref:6"><a class="footnote-ref" href="#fn:6">6</a></sup> result which will be discussed later.</p>
<h3 id="consensus"><strong>Consensus</strong><a class="headerlink" href="#consensus" title="Permanent link">&para;</a></h3>
<p>When do we say consensus is achieved? It can't be defined as all acceptors accepting a single value. By definition, the algorithm is required to provide fault 
tolerance by sustaining some of the acceptor failures.</p>
<p>Assume the system consists <strong>2N+1</strong> acceptors. Any group of atleast <strong>N+1</strong> acceptors forms a majority &amp; is called as <strong>quorum</strong>.
Any two quorums have atleast one acceptor in common. This property is called quorum intersection property.</p>
<p>If acceptors are allowed to accept only once, then acceptance of a single value by majority is made possible due to quorum intersection property.
Thus consensus can be defined as acceptance of single value by a majority of the acceptors.
Also, it should be possible to sustain upto <strong>N</strong> acceptor failures as acceptance of same value by a majority of acceptors is sufficient for consensus.</p>
<p>If a proposer receives response from atleast a majority of the acceptors, then it can conclude consensus is achieved.
Other proposers can determine whether consensus is achieved by querying the acceptors to see if a majority of the acceptors have accepted same value. 
Since consensus is defined as majority acceptance, the number of acceptors need to be <strong><em>fixed &amp; known apriori</em></strong> to the proposers.</p>
<p>Consensus needs to be achieved amidst concurrent proposals by multiple proposers while sustaining proposer &amp; acceptor failures. 
How concurrency &amp; failure affect consensus will be discussed in the next section.</p>
<div class="admonition note narrow">
<p><center><strong><em>Consensus is said to be acheived when majority of the acceptors accept same value. 
<br>Consensus is concerned with two problems viz. <u>concurrency &amp; failure</u>.</em></strong></p>
</div>
<h3 id="rule-one-proposers-retry"><strong>Rule-One: Proposers Retry</strong><a class="headerlink" href="#rule-one-proposers-retry" title="Permanent link">&para;</a></h3>
<p>It might not be possible to achieve consensus under certain circumstances. Consider the following cases:</p>
<ul>
<li>
<p><strong>Case-1:</strong> <strong>N</strong> acceptors accept value <strong>v1</strong>, and another <strong>N</strong> acceptors accept value <strong>v2</strong>. If one acceptor dies then consensus is not possible. 
In general, different group of acceptors can accept different values with non of the groups being a majority. Note that, in this case, consensus is not achieved even without any failure.</p>
</li>
<li>
<p><strong>Case-2:</strong> <strong>N+1</strong> acceptors accept value <strong>v1</strong>(i.e successfully persist the value) &amp; another group of <strong>N</strong> acceptor accept value <strong>v2</strong>. But one or more acceptors crash before sending the response to the proposer. In this case, it creates ambiguity in determining whether consensus was achieved. If the failed acceptors come back online then
proposers will be able to see that consensus is achieved.</p>
</li>
</ul>
<p>In both the cases it's a dead end, consensus was not possible due to concurrency(case-1) or failure(case-2) even with less than <strong>N</strong> failures.
To circumvent the above problem two changes are needed to the algorithm viz. acceptors are allowed to accept more than one value &amp; proposers retry.
Hence more than one attempt may be required to achieve consensus.</p>
<div class="admonition note narrow">
<p class="admonition-title"><strong><em>Rule-1: Proposers Retry</em></strong></p>
<p><strong><em><center>Due to concurrency &amp; failure, proposers might not be able to achieve consensus in a single attempt. <br>Hence proposers need to retry to achieve consensus.</em></strong></p>
</div>
<p>Now there can be multiple proposals proposing different values which are executing concurrently.
We will assume that the proposals are <strong>totally ordered</strong>, how this can be achieved will be discussed in the section <a href="#paxos-protocol">paxos protocol</a>.
Each proposal is assigned a proposal number using which the proposals will be ordered. The ones which start later have a higher proposal number.
A value is proposed using a proposal number, the acceptors store value &amp; the corresponding proposal number. Also, it's assumed that a single value is proposed per proposal number.</p>
<p>With proposals being ordered, whenever a new proposal is started there are two possibilities:</p>
<ul>
<li><strong>Rule-2:</strong> Prevent a prior ongoing proposal(having lesser proposal number) from achieving consensus.
  <br>If all prior proposals are prevented from achieving consensus then any value can be proposed in the current proposal.</li>
<li><strong>Rule-3:</strong> If above is not possible, then proposer has to choose a value from one of the ongoing proposals for the current proposal.
  A proposer might be behaving slow &amp; could complete the proposal leading to consensus or it could be the case that one or more acceptors died 
  just before sending a response to the proposer as discussed earlier.</li>
</ul>
<p>The protocol works in two phases viz. prepare &amp; accept.</p>
<ul>
<li><strong>Prepare:</strong> In the prepare phase a proposer gathers the current system state(values accepted by acceptors) by querying atleast a majority of the acceptors. 
<em>Rule-2</em> is applied at the acceptors during prepare phase, while <em>Rule-3</em> is applied at the proposer after the completion of prepare phase. 
For every new proposal both the rules are applied.</li>
<li><strong>Accept:</strong> Based on the system state gathered in prepare phase, a proposer chooses a value(ensuring safety) &amp; proposes it to the acceptors in accept phase.
Note that the accept phase can be started only after completion of prepare phase.</li>
</ul>
<h3 id="rule-two-kill-the-past"><strong>Rule-Two: Kill The Past</strong><a class="headerlink" href="#rule-two-kill-the-past" title="Permanent link">&para;</a></h3>
<p>Consider the situation in the below diagram. <strong>P1</strong> is an ongoing proposal &amp; a new proposal <strong>P2</strong> is started. 
<strong>P2</strong>'s proposal number is greater than <strong>P1</strong>'s proposal number.</p>
<div class="language-text highlight"><span class="filename">An acceptor common between two proposals hasn't accepted any value</span><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>    |&lt;---P1---&gt;|            * N1 &amp; N2: Process groups consisting of N acceptors each.
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>    +------+---+------+     * P1 &amp; P2 have an acceptor &quot;A&quot; in common, P2.proposal_number &gt; P1.proposal_number.
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>    |  N1  | A |  N2  |     * &quot;A&quot; hasn&#39;t accepted a value from P1.
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a>    +------+---+------+     * N1 &amp; N2 don&#39;t have any other acceptor in common.
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>           |&lt;---P2---&gt;|    
</span></code></pre></div>
<ol>
<li>Acceptor <strong>"A"</strong> which is common between proposals <strong>P1</strong> &amp; <strong>P2</strong> hasn't accepted any value.</li>
<li>Since acceptors in <strong>N1</strong> are not involved in <strong>P2</strong>, it is not possible for proposal <strong>P2</strong> to know what value 
acceptors in <strong>N1</strong> have accepted(or will accept in the <strong>future &amp; achieve consenus</strong>).</li>
<li><strong>P2</strong> can choose to propose any value, however it should ensure <strong>P1</strong> doesn't achieve consensus(potentially for a different value).</li>
<li>To deal with the above situation, during the prepare phase, proposer for <strong>P2</strong> extracts a promise from acceptors in <strong>N2</strong> &amp; <strong>"A"</strong> 
not to accept any proposal lesser than itself.</li>
<li>Hence proposal <strong>P1</strong> will not be able to achieve acceptance from a majority i.e <strong>P2</strong> just killed <strong>P1</strong>.
   Note that a quorum of acceptors (<strong>N2</strong> + <strong>A</strong>) have moved to a higher numbered proposal hence <strong>P1</strong> will not be able to achieve consensus.</li>
</ol>
<p>In general, there could be more than one proposal before the current proposal, all those proposals in which <em><u>at least one common acceptor</u></em> hasn't yet accepted a value will be killed by current proposal. Also, there may be more than one acceptor common between any two proposals.</p>
<div class="admonition note narrow">
<p class="admonition-title">Rule Two: Kill The Past</p>
<p><strong><em><center>During the prepare phase, extract a promise from a quorum of acceptors participating in the current proposal <br>not to accept any proposal having a proposal number lesser than itself</em></strong></p>
</div>
<h3 id="rule-three-past-is-prologue"><strong>Rule-Three: Past Is Prologue</strong><a class="headerlink" href="#rule-three-past-is-prologue" title="Permanent link">&para;</a></h3>
<p>Consider the situation in the below diagram. <strong>P1</strong> is an ongoing proposal &amp; a new proposal <strong>P2</strong> is started.</p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">Single Accepted Value From Previous Proposal</label><label for="__tabbed_1_2">Multiple Accepted Values From Different Past Proposals</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><center><strong>Note: Make sure you read next tab after reading this one.</strong></center>
  <div class="language-text highlight"><span class="filename">Acceptor A which is common between proposals P1 & P2 has accepted a value.</span><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>|&lt;---P1---&gt;|            * N1 &amp; N2: Process groups consisting of N acceptors each.
</span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a>+------+---+------+     * P1 &amp; P2 have an acceptor &quot;A&quot; in common, P2.proposal_number &gt; P1.proposal_number.
</span><span id="__span-2-3"><a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a>|  N1  | A |  N2  |     * &quot;A&quot; has already accepted a value from P1, A.value = P1.value.
</span><span id="__span-2-4"><a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a>+------+---+------+     * N1 &amp; N2 don&#39;t have any other acceptor in common.
</span><span id="__span-2-5"><a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a>       |&lt;---P2---&gt;|
</span></code></pre></div></p>
<ol>
<li>An acceptor <strong>"A"</strong> has accepted <strong>"a"</strong> as a value from <strong>P1</strong>.</li>
<li>If a different value, say <strong>"b"</strong>, were to be chosen in proposal <strong>P2</strong> then: <ul>
<li>Acceptors in <strong>N1</strong> can complete the proposal <strong>P1</strong> which chooses <strong>"a"</strong>. 
     Note that proposal <strong>P2</strong> doesn't has any control over the acceptors in <strong>N1</strong> as they are not part of the proposal.
     It's also possible <strong>P1</strong> has already reached consensus.</li>
<li>Proposer for <strong>P1</strong> would deem <strong>"a"</strong> as chosen value &amp; proposer for <strong>P2</strong> would deem <strong>"b"</strong> as chosen value.</li>
<li>Ultimately, though a majority has accepted <strong>"b"</strong> after <strong>P2</strong> completes, there would have been a <u>flip from <strong>"a"</strong> to <strong>"b"</strong></u> 
     at some point in time if proposal <strong>P1</strong> completes before <strong>P2</strong>. </li>
</ul>
</li>
<li>To avoid above situation, before proposing a value in proposal <strong>P2</strong>, the proposer tries to learn if any of the acceptors in <strong>P2</strong> had already 
     accepted a value from past proposal during the prepare phase. If so, then the previously accepted value is used for the current proposal <strong>P2</strong>.</li>
<li>We are still not done, what if more than one common acceptors have accepted different values from different past proposals.
     A question that arises is <strong>which value</strong> should be considered for the current proposal? Continue to the next tab for answer.</li>
</ol>
</div>
<div class="tabbed-block">
<p><center><strong>Note: Make sure you have read previous tab before reading this one.</strong></center></p>
<p>Given a past proposal &amp; current proposal, the past proposals will fall into two categories:</p>
<ul>
<li>At least one common acceptor hasn't accepted a value, such proposals will be killed following <strong>Rule-2</strong>.      </li>
<li>One or more common acceptors have accepted a value from past proposals. The past proposals will be in one of these states: <strong><em>dead, ongoing or consensus achieved</em></strong>. 
    However, the current proposal doesn't know about the <u>status of the past proposals</u>, a proposer might be behaving slow &amp; could complete the prosposal leading to consensus.
    Current proposal has to choose one value from the different values proposed in these past proposals ensuring <strong><em>safety</em></strong>.
    <br><strong>Note:</strong> Dead proposal means consensus can't be achieved for that proposal.</li>
</ul>
<p>Lets start from the beginning. Considering the very first two proposals, two things are possible: </p>
<ul>
<li><strong>P2</strong> proposal kills <strong>P1</strong>, the value proposed in <strong>P2</strong> &amp; <strong>P1</strong> proposals can differ(following Rule-2). <br>We get the sequence: <mark>"dead-ongoing"</mark>.</li>
<li><strong>P2</strong> chooses the same value as <strong>P1</strong>(as discussed in previous tab), both <strong>P2</strong> &amp; <strong>P1</strong> are ongoing. <br>We get the sequence: <mark>"ongoing-ongoing"</mark>.</li>
</ul>
<p>For the third proposal, the following below given scenarios are possible in the prepare phase when a query is made.
  <div class="language-text highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>    Scenario --&gt; a               b               c               d
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a>                 ------------------------------------------------------------    
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>    Proposal --&gt; dead-ongoing    dead-ongoing    dead-ongoing    dead-ongoing
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a>    Status          ^       ^       ^                       ^ 
</span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a>
</span><span id="__span-3-6"><a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a>  ^: Indicates one or more acceptors from this proposal respond with the value accepted in this propsoal  
</span><span id="__span-3-7"><a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a>     when a prepare request is made for current proposal.
</span><span id="__span-3-8"><a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a>
</span><span id="__span-3-9"><a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a>  a: The accepted values correspond to dead &amp; ongoing proposal. 
</span><span id="__span-3-10"><a id="__codelineno-3-10" name="__codelineno-3-10" href="#__codelineno-3-10"></a>     Here value corresponding to ongoing proposal needs to be considered for current proposal 
</span><span id="__span-3-11"><a id="__codelineno-3-11" name="__codelineno-3-11" href="#__codelineno-3-11"></a>     to preserve safety.
</span><span id="__span-3-12"><a id="__codelineno-3-12" name="__codelineno-3-12" href="#__codelineno-3-12"></a>
</span><span id="__span-3-13"><a id="__codelineno-3-13" name="__codelineno-3-13" href="#__codelineno-3-13"></a>  b: The accepted value corresponds to dead proposal. Since no acceptor participating in the current proposal 
</span><span id="__span-3-14"><a id="__codelineno-3-14" name="__codelineno-3-14" href="#__codelineno-3-14"></a>     has accepted a value from the ongoing proposal, the ongoing proposal will be killed.
</span><span id="__span-3-15"><a id="__codelineno-3-15" name="__codelineno-3-15" href="#__codelineno-3-15"></a>     So it is safe to consider the value corresponding to the dead proposal.
</span><span id="__span-3-16"><a id="__codelineno-3-16" name="__codelineno-3-16" href="#__codelineno-3-16"></a>
</span><span id="__span-3-17"><a id="__codelineno-3-17" name="__codelineno-3-17" href="#__codelineno-3-17"></a>  c: The accepted value corresponds to an ongoing proposal. 
</span><span id="__span-3-18"><a id="__codelineno-3-18" name="__codelineno-3-18" href="#__codelineno-3-18"></a>     It&#39;s safe to choose this value for current proposal.
</span><span id="__span-3-19"><a id="__codelineno-3-19" name="__codelineno-3-19" href="#__codelineno-3-19"></a>
</span><span id="__span-3-20"><a id="__codelineno-3-20" name="__codelineno-3-20" href="#__codelineno-3-20"></a>  d: None of the accceptors in current proposal have accepted a value in past proposals. 
</span><span id="__span-3-21"><a id="__codelineno-3-21" name="__codelineno-3-21" href="#__codelineno-3-21"></a>     All the past proposals(including already dead, aha) will get killed.
</span><span id="__span-3-22"><a id="__codelineno-3-22" name="__codelineno-3-22" href="#__codelineno-3-22"></a>     The current proposal is free to choose any value from the wild for the current proposal. 
</span></code></pre></div>
  When a new proposal <strong>P3</strong> starts, it is possible to get a sequence like: <mark>"ongoing-dead"</mark> i.e <strong>P2</strong> gets killed while <strong>P1</strong> is active.
  Though such a sequence is possible it is still equivalent to <mark>"ongoing-ongoing"</mark>, as the dead proposal will have the same value as the ongoing proposals(for safety we are concerned only with the value). In general, a sequence like <mark>"ooooddd"</mark> or <mark>"oododod"</mark> are equivalent to <mark>"ooooooo"</mark>. Generalizing, it is easy to see that we need to consider a sequence like: <mark>"ddddooooo"</mark>, dead proposals followed by ongoing proposals.</p>
<p>Given a sequence like <mark>"ddddooooo"</mark> &amp; if more than one acceptor in current proposal had already accepted a value in past proposals, then the value corresponding to the 
  <strong>highest numbered past proposal</strong> needs to considered for current proposal. If the highest numbered proposal corresponds to an ongoing proposal, the sequence gets extended with another ongoing proposal. However, if highest numbered proposal corresponds to a dead proposal then all the ongoing proposals will get killed &amp; the new sequence will have only one ongoing proposal.</p>
<p><strong>Another perspective:</strong> Assume value corresponding to highest numbered past proposal is considered for the current proposal, any prior proposal would have done the same thing. 
  In other words Paxos is a recursive algorithm, the above explanation is based on unrolling the recursive execution of Paxos algorithm.</p>
<p>Once consensus is achieved, only that value can be used in all future proposals as all future proposals will have at-least one common acceptor with
  the proposal which achieved consensus due to quorum intersection propoerty(note, any higher numbered proposal will also have same value). This holds true even if there are upto <strong>N</strong> failures. This corresponds to <strong>Case-2</strong> that was discussed under section <strong>Rule-1</strong>.</p>
<p>Also, note that acceptors need not have to remember all the values proposed in the past proposals, the one corresponding to the highest numbered proposal is sufficient.</p>
</div>
</div>
</div>
<div class="admonition note narrow">
<p class="admonition-title">Rule Three: Past Is Prologue</p>
<p><strong><em><center>If acceptors participating in the current proposal had already accepted a value from different past proposals 
then, <br>for the current proposal use the value corresponding to the highest-numbered past proposal.</em></strong></p>
</div>
<h3 id="paxos-protocol"><strong>Paxos Protocol</strong><a class="headerlink" href="#paxos-protocol" title="Permanent link">&para;</a></h3>
<p><strong>Choosing proposal number:</strong>
Whenever a new proposal is started, the below two conditions should be met w.r.t proposal number: </p>
<ul>
<li>A single value is proposed per proposal number.</li>
<li>The proposal number should be greater than all the past proposals. </li>
</ul>
<p>The following mechanism can be used to meet the above conditions.<br> 
Proposers should choose a proposal number from disjoint sets &amp; a proposer should not reuse a proposal number to propose a different value(this can be achieved if a proposer persists it's last used proposal number &amp; doesn't reuse it again). </p>
<p>Proposal number can be generated as a concatenation of two numbers: &lt;<strong><em>I</em></strong>,<strong><em>J</em></strong>&gt;, <strong><em>J</em></strong> corresponds to the proposer number(facilitates disjoint sets) &amp; <strong><em>I</em></strong> is a monotonically increasing number. At the start of a new proposal, a proposer queries atleast a majroity of the acceptors to discover the highest <strong><em>I</em></strong> value &amp; then increments it to generate it's proposal number.</p>
<p>If a proposer chooses a proposal number as above, then it need not store it's last proposal number locally on stable storage to avoid resuse of the proposal number.
This is made possible because a prepare request is made(atleast to a majority) before an accept request &amp; value comes into picture only at the accept phase. </p>
<p>The complete paxos algorithm is summarized below<sup id="fnref2:3"><a class="footnote-ref" href="#fn:3">3</a></sup>, phase-1 corresponds to prepare &amp; phase-2 corresponds to accept:</p>
<div class="admonition info">
<p class="admonition-title">Complete Paxos Protocol</p>
<div class="language-text highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>Phase 1. (a) A proposer selects a proposal number n and sends a prepare
</span><span id="__span-4-2"><a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a>         request with number n to a majority of acceptors.
</span><span id="__span-4-3"><a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>
</span><span id="__span-4-4"><a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a>         (b) If an acceptor receives a prepare request with number n greater
</span><span id="__span-4-5"><a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a>         than that of any prepare request to which it has already responded,
</span><span id="__span-4-6"><a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a>         then it responds to the request with a promise not to accept any more
</span><span id="__span-4-7"><a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a>         proposals numbered less than n and with the highest-numbered proposal
</span><span id="__span-4-8"><a id="__codelineno-4-8" name="__codelineno-4-8" href="#__codelineno-4-8"></a>         (if any) that it has accepted.  
</span><span id="__span-4-9"><a id="__codelineno-4-9" name="__codelineno-4-9" href="#__codelineno-4-9"></a>
</span><span id="__span-4-10"><a id="__codelineno-4-10" name="__codelineno-4-10" href="#__codelineno-4-10"></a>Phase 2. (a) If the proposer receives a response to its prepare requests
</span><span id="__span-4-11"><a id="__codelineno-4-11" name="__codelineno-4-11" href="#__codelineno-4-11"></a>         (numbered n) from a majority of acceptors, then it sends an accept
</span><span id="__span-4-12"><a id="__codelineno-4-12" name="__codelineno-4-12" href="#__codelineno-4-12"></a>         request to each of those acceptors for a proposal numbered n with a
</span><span id="__span-4-13"><a id="__codelineno-4-13" name="__codelineno-4-13" href="#__codelineno-4-13"></a>         value v, where v is the value of the highest-numbered proposal among
</span><span id="__span-4-14"><a id="__codelineno-4-14" name="__codelineno-4-14" href="#__codelineno-4-14"></a>         the responses, or is any value if the responses reported no proposals.
</span><span id="__span-4-15"><a id="__codelineno-4-15" name="__codelineno-4-15" href="#__codelineno-4-15"></a>
</span><span id="__span-4-16"><a id="__codelineno-4-16" name="__codelineno-4-16" href="#__codelineno-4-16"></a>         (b) If an acceptor receives an accept request for a proposal numbered
</span><span id="__span-4-17"><a id="__codelineno-4-17" name="__codelineno-4-17" href="#__codelineno-4-17"></a>         n, it accepts the proposal unless it has already responded to a prepare
</span><span id="__span-4-18"><a id="__codelineno-4-18" name="__codelineno-4-18" href="#__codelineno-4-18"></a>         request having a number greater than n.
</span></code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The quorum in the accept phase need not necessarily be the same as the one during prepare phase.</p>
<p>Since safety is guaranteed by rule-2 &amp; rule-3 during prepare phase, it doesn't matter which 
acceptors are part of the quorum during accept phase. However, checkout this 
<a href="https://brooker.co.za/blog/2021/11/16/paxos.html">The Bug in Paxos Made Simple</a>.</p>
</div>
</div>
<h3 id="discussion"><strong>Discussion</strong><a class="headerlink" href="#discussion" title="Permanent link">&para;</a></h3>
<h4 id="moment-of-consensus">Moment of consensus<a class="headerlink" href="#moment-of-consensus" title="Permanent link">&para;</a></h4>
<p>When do we say consensus is achieved? It's at the moment the last acceptor in a quorum successfully persists the accepted value.
Interestingly, neither the proposer nor any of the acceptors know about this celebratory moment.
Both the proposer &amp; the acceptor may fail the very next moment. 
However, from this moment onwards, for any new proposal only <strong>Rule-3</strong> will apply &amp; consensus can only be achieved for the same value. </p>
<p>Note that an acceptor need to persist proposal number(during prepare phase) &amp; accepted value(during accept phase) before replying to the
the proposer to ensure safety.</p>
<h4 id="time-order">Time &amp; Order<a class="headerlink" href="#time-order" title="Permanent link">&para;</a></h4>
<p>How do we establish order(i.e one occurred before the other) between events happening at different places(i.e processes) in a distributed system without a global reference like clock.
Lamport has addressed this problem in a paper<sup id="fnref:7"><a class="footnote-ref" href="#fn:7">7</a></sup>. To establish order between two events in a distributed system either of the below given two conditions is required:</p>
<ul>
<li>Events happen on the same process. </li>
<li>A message is sent from one process to another. </li>
</ul>
<p>Here we want to establish order between proposals that are all started on different proposers.
When a prepare request is made by a proposer the proposal information(i.e proposal number) is made available on a quorum of acceptors. When a proposer wants to start new proposal a query is made to atleast a quorum of acceptors inorder to choose a proposal number. Thus these two events <strong>serialize</strong> on the common acceptors in the quorum(i.e <em><u>the first condition mentioned above</u></em>). This fact is leveraged by the mechanism explained in the <a href="#paxos-protocol">paxos protocol</a> while choosing a proposal number. Hence proposal numbers can be thought of as Lamport timestamps.</p>
<p>Note that, proposal numbers need not be lamport timestamps. Proposers may choose any random number, <strong>Rule-2</strong> simply disallows lesser numbered proposals.
On a sidenote, since we are talking about space(different processes) &amp; time(order of events), one can look at "moment of consensus" as occurring at a particular <u><strong><em>place &amp; time</em></strong></u>.</p>
<h4 id="safety-liveness_1">Safety &amp; Liveness<a class="headerlink" href="#safety-liveness_1" title="Permanent link">&para;</a></h4>
<p><strong>Safety:</strong>
Earlier we stated agreement as safety property for Paxos.
However that's still a very high level requirement, safety property needs to be defined considering multiple concurrent proposals.
Given multiple concurrent proposals below given conditions guarantee the agreement condition i.e single value is chosen.</p>
<ul>
<li>
<p>If a value <strong>v</strong> is being chosen for proposal P then no value other than <strong>v</strong> can be chosen for any proposal Q &lt; P.
  This translates to below conditions:</p>
<ul>
<li>No value is chosen in any propsal Q &lt; P i.e proposal will not complete, rule-2 is used to meet this condition.</li>
<li>Value <strong>v</strong> is already chosen or can be chosen(proposal being in progress), rule-3 is used to meet this condition.</li>
</ul>
<p>In general, for any new proposal both the rules are applied i.e some proposals get killed by applying <strong>rule-2</strong>, while a value for current proposal 
gets decided as per <strong>rule-3</strong>.</p>
</li>
<li>
<p>A single a value is proposed per proposal number.
  Though this condition does not lead to safety violation if it's not satisfied, it's required to avoid confusion.
  <br>For safety violation a different value needs to be chosen. Let's say an acceptor <strong>A</strong> has accepted value <strong>x</strong>, and <strong>N+1</strong> acceptors accepted 
  value <strong>y</strong> for same proposal number. Assume acceptor <strong>A</strong> is part of a quorum for any new proposal, atleast one acceptor from the remaining <strong>N+1</strong> is required for current proposal
  to form a quorum. This only leads to confusion w.r.t the value to used for current proposal.</p>
</li>
</ul>
<p><strong>Liveness:</strong>
<strong>Rule-2</strong> causes liveness issue. Consider the below diagram in which two proposers keep killing each other's proposals forever.
A proposer <strong>P1</strong> starts a proposal &amp; before it can start accept phase another proposer <strong>P2</strong> starts a new proposal.
And this process continues forever &amp; consensus will never be achieved. 
For simplicity, the common acceptor is shown to be the same throughout.
Note that the scenario can be generalized to more than two proposers with newer proposals not allowing older proposals to compelete &amp; 
new proposals keep getting started forever. This issue is due to the famous FLP<sup id="fnref2:6"><a class="footnote-ref" href="#fn:6">6</a></sup> result.</p>
<div class="language-text highlight"><span class="filename">Paxos liveness issue</span><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>P1 ---&lt;1&gt;---------[1,a]----&lt;3&gt;---------------[3,a]----      &lt;n&gt;: proposal request
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a>        \           \       \                  \            [&lt;proposal-no&gt;, &lt;value&gt;]: accept request  
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>         \           \       \                  \           x: rejected
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a>A1 ------&lt;1&gt;---&lt;2&gt;----x------&lt;3&gt;----x----&lt;4&gt;-----x---
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a>               /                   /      / 
</span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a>              /                   /      / 
</span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a>P2 ---------&lt;2&gt;----------------[2,b]----&lt;4&gt;----------
</span></code></pre></div>
<p>However this is not a major issue in practice. 
Consensus terminates if there is single leader for sufficient time so that it can complete both the phases viz. prepare &amp; accept.
The issue can be avoided in practice by using techniques like randomization.</p>
<div class="admonition note narrow">
<p><center><strong><em>Safety &amp; Liveness properties are better way to reason about concurrent algorithms as number of possible executions<br>for a concurrent algorithm could be on astronomical scale.</em></strong></p>
</div>
<p>For more details go through the following presentations from Leslie Lamport:</p>
<ul>
<li>Voting Algorithm:  <a href="https://www.youtube.com/watch?v=tw3gsBms-f8">Leslie Lamport  The Paxos algorithm or how to win a Turing Award. Part 1.</a></li>
<li>Paxos Algorithm: <a href="https://www.youtube.com/watch?v=8-Bc5Lqgx_c">Leslie Lamport  The Paxos algorithm or how to win a Turing Award. Part 2.</a>  </li>
</ul>
<p>These presentations are highly recommended. A key take away from the above presentation is about how Leslie Lamport uses <a href="https://youtu.be/pgWTmOyUjtM?t=517">abstraction</a> (i.e remove irrelevant detail). Voting algorithm is presented as precursor to Paxos, messaging is considered as a detail &amp; proposers are abstracted out. 
Acceptors need information to make decisions, how this information is made available is immaterial, instead what an acceptor does with the available information is the main concern. 
What Leslie Lamport refers to as ballot in the above videos is actually proposal number. The presentation uses TLA+[^], Paxos algorithm is formally proven using TLA+.  </p>
<h4 id="asynchrony">Asynchrony<a class="headerlink" href="#asynchrony" title="Permanent link">&para;</a></h4>
<p>Asynchrony assumption leads to failure detection impossibility which in turn leads to multiple proposers. 
With multiple proposers concurrency comes into picture &amp; concurrency means complexity. 
That begs us to ask the question - are the assumptions too stringent which results in algorithm complexity.
Do the timing assumptions really matter in practice or are they merely of theoretical interest. Are we being pragmatic or a purist?</p>
<p>One might be tempted to think, for practical applications timeout could still be a viable option i.e after a certain time period
a process can be considered to have failed. However it is not that simple. 
If you choose the timeout too low, safety is affected as the suspected process might come back &amp; start participating in the 
algorithm creating adverse affects, choose it too large system availability is affected. 
Also, timeout can't be chosen statically, it depends on the network conditions &amp; needs to be tuned dynamically for optimal performance.</p>
<p>Since Paxos is used in building very fundamental primitives like distributed lock safety guarantees are of utmost importance.
Fundamental primitives like lock can't be unreliable. A compromise in safety means adverse affects on the whole system 
&amp; recovering it may lead to long outages or could even result in irrecoverable damages like data loss.</p>
<p>Some stories from the trenchies are discussed in this paper: <a href="https://dl.acm.org/doi/pdf/10.1145/2643130">The network is reliable</a>.
At GitHub, a 90 second network delay due to network partition caused processes killing each other by issuing STONITH messages.
This is exactly what we are discussing about w.r.t timing assumptions. </p>
<div class="admonition quote">
<p class="admonition-title">A github story</p>
<p>This 90-second network partition caused fileservers using Pacemaker and DRBD for HA failover to declare each other dead, and to issue STONITH (Shoot The Other Node In The Head) messages to one another. The network partition delayed delivery of those messages, causing some fileserver pairs to believe they were both active. When the network recovered, both nodes shot each other at the same time. With both nodes dead, files belonging to the pair were unavailable.</p>
</div>
<p>If an algorithm is affected by external environment factors like time then the algorithm's behaviour could be unpredictable. 
In another instance leap second affected linux mutex<sup id="fnref:8"><a class="footnote-ref" href="#fn:8">8</a></sup><sup>,</sup><sup id="fnref:9"><a class="footnote-ref" href="#fn:9">9</a></sup> which affected systems globally. It's best if time can be taken out of the equation. 
It's good that consensus does not need to depend on time but that's the not case for a mutex, if you are interested 
<strong>ref:</strong> <em>section 3.3: Mutual Exclusion versus Producer-Consumer Synchronization</em>(Concurrency, The works of Leslie Lamport).</p>
<p>Further discussion about the topic can be found in the book Replication Theory, <em>Chapter 4: Stumbling over Consensus Research: Misunderstandings and Issues</em> &amp; 
the paper <em>Consensus: The big misunderstanding</em><sup id="fnref:10"><a class="footnote-ref" href="#fn:10">10</a></sup></p>
<p>There has been some work on consensus considering partial synchroncy<sup id="fnref:11"><a class="footnote-ref" href="#fn:11">11</a></sup><sup>,</sup><sup id="fnref:12"><a class="footnote-ref" href="#fn:12">12</a></sup>.</p>
<p>On a independent note, for further exploration refer to the history<sup id="fnref:13"><a class="footnote-ref" href="#fn:13">13</a></sup> &amp; paxos variants<sup id="fnref:14"><a class="footnote-ref" href="#fn:14">14</a></sup>.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Implementing Fault-Tolerant Services Using the State Machine Approach: <a href="https://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf">https://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Building Highly Available Systems: <a href="https://www.microsoft.com/en-us/research/publication/how-to-build-a-highly-available-system-using-consensus">https://www.microsoft.com/en-us/research/publication/how-to-build-a-highly-available-system-using-consensus</a>&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Paxos Made Simple: <a href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">https://lamport.azurewebsites.net/pubs/paxos-simple.pdf</a>&#160;<a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:3" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Proving the Correctness of Multiprocess Programs: <a href="https://lamport.azurewebsites.net/pubs/proving.pdf">https://lamport.azurewebsites.net/pubs/proving.pdf</a>&#160;<a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>Defining Liveness: <a href="https://cs.nyu.edu/~apanda/classes/fa22/papers/alpern85defining.pdf">https://cs.nyu.edu/~apanda/classes/fa22/papers/alpern85defining.pdf</a>&#160;<a class="footnote-backref" href="#fnref:5" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>Impossibility of Distributed Consensus with One Faulty Process: <a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf</a>&#160;<a class="footnote-backref" href="#fnref:6" title="Jump back to footnote 6 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:6" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>Time, Clocks, and the Ordering of Events in a Distributed System: <a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">https://lamport.azurewebsites.net/pubs/time-clocks.pdf</a>&#160;<a class="footnote-backref" href="#fnref:7" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:8">
<p>Leap Second crashes half the internet: <a href="https://www.somebits.com/weblog/tech/bad/leap-second-2012.html">https://www.somebits.com/weblog/tech/bad/leap-second-2012.html</a>&#160;<a class="footnote-backref" href="#fnref:8" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:9">
<p>The Inside Story of the Extra Second That Crashed the Web: <a href="https://www.wired.com/2012/07/leap-second-glitch-explained/">https://www.wired.com/2012/07/leap-second-glitch-explained/</a>&#160;<a class="footnote-backref" href="#fnref:9" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:10">
<p>Consensus: The big misunderstanding: <a href="https://web.cecs.pdx.edu/~greenwd/guerraoui97consensus.pdf">https://web.cecs.pdx.edu/~greenwd/guerraoui97consensus.pdf</a>&#160;<a class="footnote-backref" href="#fnref:10" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:11">
<p>On the Minimal Synchronism Needed for Distributed Consensus: <a href="https://dl.acm.org/doi/10.1145/7531.7533">https://dl.acm.org/doi/10.1145/7531.7533</a>&#160;<a class="footnote-backref" href="#fnref:11" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:12">
<p>Consensus in the Presence of Partial Synchrony: <a href="https://dl.acm.org/doi/10.1145/42282.42283">https://dl.acm.org/doi/10.1145/42282.42283</a>.&#160;<a class="footnote-backref" href="#fnref:12" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:13">
<p>A brief history of Consensus, 2PC &amp; Transaction Commit: <a href="https://betathoughts.blogspot.com/2007/06">https://betathoughts.blogspot.com/2007/06</a>&#160;<a class="footnote-backref" href="#fnref:13" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
<li id="fn:14">
<p>Paxos Variants: <a href="https://paxos.systems/variants">https://paxos.systems/variants</a>&#160;<a class="footnote-backref" href="#fnref:14" title="Jump back to footnote 14 in the text">&#8617;</a></p>
</li>
</ol>
</div>







  
  




  



                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.tabs", "toc.follow", "content.action.edit", "navigation.top"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>